// ---------
// Datasource & Generator
// ---------
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ---------
// Enums
// ---------
// If your DB already has a ReleaseType enum with different members/casing,
// you can change these names to match. Your import code will still work.
enum ReleaseType {
  single
  album
  compilation
}

// ---------
// Models
// ---------

model Artist {
  id       String   @id                 // text
  name     String
  country  String?

  // Back-rel to Release via Release.artistId
  releases Release[]
}

model Release {
  id             String       @id       // text
  artistId       String
  artist         Artist       @relation(fields: [artistId], references: [id])

  title          String
  type           ReleaseType
  releaseDate    DateTime?
  label          String?
  coverUrl       String?
  isMena         Boolean      @default(false)

  // Use this as the only unique for de-duping Spotify imports
  spotifyTrackId String?      @unique

  // Back-relations to child tables
  genres         ReleaseGenre[]
  ratings        AudienceRating[]
  score          ReleaseScore?

  @@index([artistId])
  // Make sure this is NOT present anymore:
  // @@unique([artistId, title])
}

model Genre {
  id       Int            @id @default(autoincrement())
  name     String
  releases ReleaseGenre[]
}

model ReleaseGenre {
  // Join table between Release and Genre
  releaseId String
  release   Release @relation(fields: [releaseId], references: [id])

  genreId   Int
  genre     Genre   @relation(fields: [genreId], references: [id])

  @@id([releaseId, genreId])
}

model AudienceRating {
  id         String   @id @default(cuid())
  releaseId  String
  release    Release  @relation(fields: [releaseId], references: [id])

  userId     String
  stars      Int
  comment    String?
  createdAt  DateTime @default(now())
  ipHash     String?
  subnetHash String?
  ipVersion  Int?
}

model ReleaseScore {
  // One-to-one with Release
  releaseId      String  @id
  release        Release @relation(fields: [releaseId], references: [id])

  audienceScore  Float?
  audienceCount  Int     @default(0)
  lastCalculated DateTime @default(now())
}

model User {
  id        String   @id
  email     String
  name      String?
  createdAt DateTime @default(now())

  // If you later enforce userId as FK in AudienceRating, you can add:
  // ratings AudienceRating[]
}
