// prisma/schema.prisma

// ----------
// Datasource & generator (keep yours)
// ----------
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ----------
// Enums
// ----------
// If your DB already has an enum, keep its exact members.
// Example (lowercase):
enum ReleaseType {
  single
  album
  compilation
}

// ----------
// Models
// ----------
model Artist {
  id        String   @id          // text in your DB
  name      String
  country   String?
  // Back-relation to Release via Release.artistId
  releases  Release[]
}

model Release {
  id             String       @id          // text in your DB
  artistId       String
  // Relation to Artist using artistId FK
  artist         Artist       @relation(fields: [artistId], references: [id])

  title          String
  type           ReleaseType
  releaseDate    DateTime?
  label          String?
  coverUrl       String?
  isMena         Boolean      @default(false)

  // Unique key we decided to use for upserts
  spotifyTrackId String?      @unique

  // Back-relations to children that reference releaseId
  genres         ReleaseGenre[]
  ratings        AudienceRating[]
  score          ReleaseScore?

  @@index([artistId])
  // Remove this if it exists in your current file:
  // @@unique([artistId, title])
}

model Genre {
  id      Int            @id @default(autoincrement())
  name    String
  // Back-relation for the join table
  releases ReleaseGenre[]
}

model ReleaseGenre {
  // FK to Release
  releaseId String
  release   Release   @relation(fields: [releaseId], references: [id])

  // FK to Genre
  genreId   Int
  genre     Genre     @relation(fields: [genreId], references: [id])

  // Composite PK for the join table
  @@id([releaseId, genreId])
}

model AudienceRating {
  id          String    @id @default(cuid())  // you already had cuid() in logs
  // FK to Release
  releaseId   String
  release     Release   @relation(fields: [releaseId], references: [id])

  userId      String
  stars       Int
  comment     String?
  createdAt   DateTime  @default(now())
  ipHash      String?
  subnetHash  String?
  ipVersion   Int?
}

model ReleaseScore {
  // One-to-one with Release via releaseId as PK & FK
  releaseId      String   @id
  release        Release  @relation(fields: [releaseId], references: [id])

  audienceScore  Float?
  audienceCount  Int      @default(0)
  lastCalculated DateTime @default(now())
}

model User {
  id        String   @id
  email     String
  name      String?
  createdAt DateTime @default(now())

  // Optional: back-relation if you ever tie ratings to users via userId as FK.
  // (Only add if you actually enforce FK userId -> User.id in DB)
  // ratings  AudienceRating[]
}
